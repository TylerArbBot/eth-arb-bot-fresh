// bot.js
require("dotenv").config();

const {
  JsonRpcProvider,
  Wallet,
  Contract,
  parseUnits,
  formatUnits
} = require("ethers");
const fs = require("fs");
const nodemailer = require("nodemailer");
const { FlashbotsBundleProvider } = require("@flashbots/ethers-provider-bundle");

(async () => {
  // ‚îÄ‚îÄ 1) Providers & Wallets ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const provider = new JsonRpcProvider(process.env.INFURA_L2_URL);
  const wallet = new Wallet(process.env.PRIVATE_KEY, provider);

  // ‚îÄ‚îÄ 2) Routers for off-chain price checks ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const uniV2Abi = [
    "function getAmountsOut(uint256 amountIn, address[] calldata path) view returns (uint256[] memory)"
  ];
  const router1 = new Contract(
    process.env.UNISWAP_ROUTER_L2,
    uniV2Abi,
    provider
  );
  const router2 = new Contract(
    process.env.SUSHI_ROUTER_L2,
    uniV2Abi,
    provider
  );

  // ‚îÄ‚îÄ 3) Attach your deployed arbitrage contract ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const arbAbi = require(
    "./artifacts/contracts/MemoryArbBot.sol/MemoryArbBot.json"
  ).abi;
  const arbBot = new Contract(
    process.env.ARBITRAGE_CONTRACT,
    arbAbi,
    wallet
  );

  // ‚îÄ‚îÄ 4) Email transporter ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const transporter = nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: process.env.EMAIL_USER,
      pass: process.env.EMAIL_PASS,
    },
  });
  async function sendAlert(subject, text) {
    await transporter.sendMail({
      from: process.env.EMAIL_USER,
      to: process.env.EMAIL_TO,
      subject,
      text,
    });
  }

  // ‚îÄ‚îÄ 5) Strategy parameters ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const TRADE_AMOUNT = parseUnits(process.env.TRADE_AMOUNT, 18);
  const network = await provider.getNetwork();
  const MIN_PROFIT = parseUnits(
    network.chainId === 42161
      ? process.env.MIN_PROFIT_MAINNET
      : process.env.MIN_PROFIT_TESTNET,
    18
  );
  const WITHDRAW_THRESHOLD = parseUnits(
    process.env.WITHDRAW_THRESHOLD,
    18
  );
  const INTERVAL_MS = parseInt(process.env.INTERVAL_MS, 10);

  // ‚îÄ‚îÄ 6) Metrics setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const METRICS_FILE = "metrics.csv";
  const DEBUG_FILE = "metrics_debug.csv";
  let tradeCount = 0;
  let cumProfit = parseUnits("0", 18);

  if (!fs.existsSync(METRICS_FILE)) {
    fs.writeFileSync(
      METRICS_FILE,
      "trade,timestamp,profit,gasUsed,gasCost,netProfit\n"
    );
  }
  if (!fs.existsSync(DEBUG_FILE)) {
    fs.writeFileSync(
      DEBUG_FILE,
      "tick,timestamp,offchain,onchain\n"
    );
  }

  // ‚îÄ‚îÄ 7) Setup Flashbots ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const authSigner = new Wallet(
    process.env.FLASHBOTS_SIGNER_PRIVATE_KEY,
    provider
  );
  const flashbotsProvider = await FlashbotsBundleProvider.create(
    provider,
    authSigner,
    process.env.FLASHBOTS_RELAY_URL
  );

  // ‚îÄ‚îÄ 8) Start main loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  console.log("üöÄ Starting arbitrage loop with Flashbots‚Ä¶");
  setInterval(async () => {
    try {
      // 1Ô∏è‚É£ Off-chain simulate profit
      const amounts = await router1.getAmountsOut(
        TRADE_AMOUNT,
        [process.env.TOKEN0_ADDRESS, process.env.TOKEN1_ADDRESS]
      );
      const potentialOff =
        amounts[1] > TRADE_AMOUNT ? amounts[1] - TRADE_AMOUNT : 0n;
      console.log(
        "Off-chain profit:",
        formatUnits(potentialOff, 18),
        "ETH"
      );

      // 2Ô∏è‚É£ On-chain simulate
      let potentialOn;
      try {
        potentialOn = await arbBot.simulateArb(TRADE_AMOUNT);
        console.log(
          "On-chain simulated profit:",
          formatUnits(potentialOn, 18),
          "ETH"
        );
      } catch (err) {
        console.log("‚ö†Ô∏è On-chain simulate failed:", err.message);
        potentialOn = 0n;
      }

      // üìü Debug log every tick
      fs.appendFileSync(
        DEBUG_FILE,
        [
          tradeCount,
          new Date().toISOString(),
          formatUnits(potentialOff, 18),
          formatUnits(potentialOn, 18)
        ].join(",") + "\n"
      );

      //  Check profit threshold
      if (potentialOn < MIN_PROFIT) {
        console.log("‚ö†Ô∏è Below MIN_PROFIT, skipping execution");
        return;
      }

      // 3Ô∏è‚É£ Build & send Flashbots bundle
      const execTx = await arbBot.populateTransaction.executeArb(
        TRADE_AMOUNT,
        MIN_PROFIT
      );
      const withdrawTx = await arbBot.populateTransaction.withdrawTokens(
        process.env.TOKEN0_ADDRESS
      );

      const signedBundle = await flashbotsProvider.signBundle([
        { signer: wallet, transaction: execTx },
        { signer: wallet, transaction: withdrawTx }
      ]);

      const blockNumber = await provider.getBlockNumber();
      const bundleResponse = await flashbotsProvider.sendRawBundle(
        signedBundle,
        blockNumber + 1
      );
      const bundleReceipt = await bundleResponse.wait();

      if ("error" in bundleReceipt) {
        console.error("Flashbots bundle error:", bundleReceipt.error);
        return;
      }
      console.log(
        `‚úÖ Bundle included in block ${bundleReceipt.blockNumber}`
      );

      // 4Ô∏è‚É£ Compute gas & net profit
      const receipt = bundleReceipt.transactions[0].receipt;
      const gasUsed = receipt.gasUsed;
      const gasCost = gasUsed * receipt.effectiveGasPrice;
      const netProfit = potentialOn - gasCost;

      // 5Ô∏è‚É£ Log metrics & send alerts
      tradeCount++;
      const now = new Date().toISOString();
      fs.appendFileSync(
        METRICS_FILE,
        [
          tradeCount,
          now,
          formatUnits(potentialOn, 18),
          gasUsed.toString(),
          formatUnits(gasCost, 18),
          formatUnits(netProfit, 18)
        ].join(",") + "\n"
      );

      if (cumProfit + netProfit >= WITHDRAW_THRESHOLD) {
        console.log("üîÑ Threshold reached‚Äîsending withdrawal alert");
        await sendAlert(
          "üîî Auto-Withdrawal",
          `Withdrew ${formatUnits(cumProfit + netProfit, 18)} ETH profit`
        );
        cumProfit = parseUnits("0", 18);
      } else {
        cumProfit += netProfit;
      }

      await sendAlert(
        `‚úÖ Arb #${tradeCount}`,
        `Profit: ${formatUnits(netProfit, 18)} ETH\nTx: bundle @ block ${bundleReceipt.blockNumber}`
      );
    } catch (err) {
      console.error("‚ùå Execution error:", err);
    }
  }, INTERVAL_MS);
})();
